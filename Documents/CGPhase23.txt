ConsignmentPro - Phases 2 & 3 Requirements Specification
Phase 2: Stripe Subscriptions & Square POS Integration
Timeline: Weeks 4-6 (3 weeks)
Phase 2 Overview
Transform Phase 1 MVP into a revenue-generating SaaS by adding Stripe subscriptions with founder pricing, automating transaction entry via Square POS, and adding photo uploads and email notifications.
Prerequisites: Phase 1 complete and deployed

Phase 2 Requirements
2.1 Stripe Subscription Management
Business Requirements:

Accept payments via Stripe Checkout
Offer 14-day free trial (no credit card required for trial start)
Implement tiered pricing: Basic ($79), Standard ($129), Plus ($179), Premium ($229)
Founder pricing for first 30 customers:

First 10: $39/mo locked forever
Next 20: $59/mo locked forever
Then: $79/mo locked forever


Allow customers to upgrade/downgrade tiers
Allow customers to cancel (cancel at period end, not immediate)
Provide Stripe Customer Portal for payment method updates
Track subscription status in Organization table
Handle failed payments gracefully (email notification + grace period)

Technical Requirements:
New Database Entities:
SubscriptionEvent (audit log)
- OrganizationId (FK)
- EventType (string: subscription.created, payment_succeeded, etc.)
- StripeEventId (string, unique)
- RawJson (text: full webhook payload)
- Processed (bool)
- ProcessedAt (datetime?)
- ErrorMessage (string?)
Organization Table (already has Stripe fields from Phase 1):

StripeCustomerId
StripeSubscriptionId
StripePriceId
SubscriptionStatus (enum: Trial, Active, PastDue, Canceled, Incomplete)
SubscriptionTier (enum: Basic, Standard, Plus, Premium)
SubscriptionStartDate
SubscriptionEndDate (current period end)
IsFounderPricing (bool)
FounderTier (int?: 1, 2, 3)

Backend Service: IStripeService
Methods needed:

CreateCustomerAsync(organizationId, email, organizationName) → customerId
CreateSubscriptionAsync(organizationId, tier, isFounder, founderTier?) → SubscriptionResult with clientSecret
UpdateSubscriptionAsync(organizationId, newTier) → SubscriptionResult
CancelSubscriptionAsync(organizationId, immediately = false) → bool
CreateBillingPortalSessionAsync(organizationId, returnUrl) → portalUrl
ProcessWebhookAsync(json, stripeSignature) → void
ValidateFounderEligibilityAsync() → (isEligible, tier 1/2/3)

API Endpoints:
POST   /api/subscription/create          - Create subscription (returns clientSecret for Stripe Elements)
POST   /api/subscription/cancel          - Cancel subscription
POST   /api/subscription/update-tier     - Upgrade/downgrade
GET    /api/subscription/status          - Get current subscription info
POST   /api/subscription/billing-portal  - Get Stripe portal URL
POST   /api/subscription/webhook         - Stripe webhook endpoint (AllowAnonymous)
GET    /api/subscription/founder-status  - Check founder pricing availability
Webhook Events to Handle:

customer.subscription.created - Update org status to Trial
customer.subscription.updated - Update org status/tier
customer.subscription.deleted - Mark as Canceled
invoice.payment_succeeded - Update status to Active, extend period end
invoice.payment_failed - Mark PastDue, send email

Frontend Requirements:

Pricing page showing all tiers + founder pricing banner (if available)
Stripe Elements integration for payment method collection
Subscription status badge in header (Trial: X days left, Active, Past Due)
Settings > Billing page:

Current plan & price
Next billing date
Upgrade/downgrade buttons
"Manage Payment Method" button (opens Stripe portal)
"Cancel Subscription" button


Trial expiration warning (3 days before trial ends)
Payment failure modal with "Update Payment Method" button

Constraints & Rules:

Trial users have full access to Basic tier features
After trial: require active subscription to use app (show paywall)
Founder pricing: Automatically determine tier based on count of existing founder customers
Subscription tiers unlock features:

Basic: Core platform only
Standard: + Square POS integration
Plus: + Square Online integration
Premium: + QuickBooks Online auto-sync


If customer downgrades: change takes effect at next billing period
If customer upgrades: prorate and charge immediately


2.2 Square POS Integration
Business Requirements:

Allow shop owners to connect their Square POS account
OAuth flow to authorize access (read payments, read items)
Auto-sync transactions from Square nightly
Match Square payments to ConsignmentPro items by SKU
For unmatched transactions: show manual matching UI
Display sync status & history
Allow manual sync trigger
Only available for Standard tier and above

Technical Requirements:
New Database Entities:
SquareConnection
- OrganizationId (FK, unique)
- IsConnected (bool)
- MerchantId (string?)
- AccessToken (string, encrypted)
- RefreshToken (string, encrypted)
- TokenExpiry (datetime?)
- LocationId (string?) - Square location ID
- LocationName (string?)
- LastSyncAt (datetime?)
- AutoSync (bool, default true)
- SyncSchedule (string: cron expression, default "0 0 * * *")

SquareSyncLog
- OrganizationId (FK)
- SyncStarted (datetime)
- SyncCompleted (datetime?)
- Success (bool)
- TransactionsImported (int)
- TransactionsMatched (int)
- TransactionsUnmatched (int)
- ErrorMessage (string?)
- Details (JSON: array of {paymentId, status, matchedItemId?})
Transaction Table Updates:
Add fields:

SquarePaymentId (string?, unique)
SquareLocationId (string?)
ImportedFromSquare (bool, default false)
SquareCreatedAt (datetime?)

Backend Service: ISquareService
Methods needed:

GetAuthorizationUrlAsync(organizationId) → OAuth URL
ExchangeCodeForTokenAsync(code, state) → OAuthResult
DisconnectAsync(organizationId) → bool
RefreshAccessTokenAsync(organizationId) → bool
SyncTransactionsAsync(organizationId, startDate?, endDate?) → SyncResult
GetUnmatchedTransactionsAsync(organizationId) → List<UnmatchedTransaction>
MatchTransactionAsync(organizationId, squarePaymentId, itemId) → bool
ProcessWebhookAsync(body, signature) → void (future: real-time sync)

Matching Logic:

Auto-match: If Square payment has SKU that exactly matches a ConsignmentPro item SKU → create transaction automatically
Fuzzy match: Suggest possible matches based on:

SKU similarity (Levenshtein distance)
Price match (within $5)
Time window (item created before payment date)
Score each match 0-100, show top 5 suggestions


Manual match: Shop owner selects correct item from dropdown
Skip: Shop owner can mark Square payment as "not in system" (e.g., non-consignment sale)

Sync Process:

Fetch payments from Square API for date range (default: last 7 days)
For each payment:

Check if already imported (by SquarePaymentId)
If imported: skip
If not: attempt auto-match by SKU
If matched: create Transaction, update Item status to Sold
If not matched: add to unmatched list


Log sync results in SquareSyncLog
Return summary: {total, matched, unmatched, skipped}

API Endpoints:
GET    /api/square/connect-url           - Get OAuth URL
GET    /api/square/oauth-callback        - OAuth callback (exchange code)
POST   /api/square/disconnect            - Disconnect Square
GET    /api/square/status                - Connection status & last sync
POST   /api/square/sync                  - Trigger manual sync
GET    /api/square/unmatched             - Get unmatched transactions
POST   /api/square/match                 - Match payment to item {squarePaymentId, itemId}
POST   /api/square/skip                  - Mark payment as non-consignment
GET    /api/square/sync-logs             - Get sync history
POST   /api/square/webhook               - Square webhook (future)
Frontend Requirements:

Settings > Integrations > Square POS:

"Connect Square" button (redirects to OAuth)
Connection status badge (Connected since X, Last sync: X)
"Disconnect" button
"Sync Now" button
Auto-sync toggle + schedule selector (daily, twice daily, manual only)


Dashboard widget: "Unmatched Square Transactions" (count badge)
New page: Unmatched Transactions

Table: Date, Amount, Square Item Name, Square SKU, Status
"Match" button → modal with:

Suggested matches (scored 0-100)
Search box to find item manually
"Skip" option


Bulk actions: "Match All Auto-Suggestions", "Skip All"


Transaction list: Show "Square" icon for imported transactions
Sync history page (Settings > Square > History):

Table: Date, Duration, Matched, Unmatched, Status, Details



Constraints:

Only one Square location supported per organization (can select which location in settings)
Token refresh: Auto-refresh when < 7 days until expiry
Rate limits: Square API allows 10 requests/second - implement exponential backoff
Duplicate prevention: Never import same SquarePaymentId twice
Tier gate: Square features only accessible for Standard tier+


2.3 Photo Upload (Azure Blob Storage)
Business Requirements:

Allow shop owners to upload item photos (up to 5 photos per item)
Show photos in item details, transaction history, payout reports
Photos stored in cloud (Azure Blob Storage)
Generate thumbnails automatically
Support JPEG, PNG, WEBP (max 10MB per photo)

Technical Requirements:
Storage Structure:
Container: consignmentpro-photos
Path: {organizationId}/{itemId}/{guid}.{extension}
Thumbnails: {organizationId}/{itemId}/thumbnails/{guid}_thumb.{extension}
Item Table Updates:

Photos field already exists as JSON array: ["url1", "url2"]
Update to store full URLs: ["https://storage.../photo1.jpg", "..."]

Backend Service: IPhotoService
Methods:

UploadPhotoAsync(organizationId, itemId, fileStream, fileName) → photoUrl
DeletePhotoAsync(organizationId, photoUrl) → bool
GenerateThumbnailAsync(photoUrl) → thumbnailUrl
GetPhotosAsync(itemId) → List<PhotoInfo>

API Endpoints:
POST   /api/photos/upload          - Upload photo (multipart/form-data)
DELETE /api/photos/{photoId}       - Delete photo
GET    /api/items/{itemId}/photos  - Get all photos for item
Frontend Requirements:

Item form: Photo upload widget

Drag & drop or click to browse
Show upload progress
Preview uploaded photos
Reorder photos (drag & drop)
Delete photo button (with confirmation)
Max 5 photos validation


Item list: Show thumbnail of first photo
Item details: Photo carousel/gallery
Transaction/Payout reports: Include thumbnail

Constraints:

Max 5 photos per item
Max 10MB per file
Allowed formats: JPEG, PNG, WEBP
Generate 200x200px thumbnails
Delete blob when item is deleted (cascade)
SAS tokens for secure access (if needed)


2.4 Email Service (SendGrid)
Business Requirements:

Send transactional emails for key events
Professional email templates
Track email delivery status
Email types needed (Phase 2):

Welcome email (registration)
Trial expiring (3 days before)
Payment failed
Payment succeeded (receipt)
Square sync failed
(Phase 3: Provider invitations, item sold, payout ready)



Technical Requirements:
Backend Service: IEmailService
Methods:

SendWelcomeEmailAsync(email, organizationName) → bool
SendTrialExpiringEmailAsync(email, daysRemaining) → bool
SendPaymentFailedEmailAsync(email, amount, retryDate) → bool
SendPaymentReceiptAsync(email, amount, invoiceUrl) → bool
SendSyncErrorEmailAsync(email, integration, errorMessage) → bool

Email Templates:

Use SendGrid Dynamic Templates
Include: Logo, organization name, CTA buttons, unsubscribe link
Mobile-responsive

API Endpoints:

No direct endpoints (service layer only)
Admin endpoint (future): GET /api/emails/logs

Constraints:

Use SendGrid API (not SMTP)
Store SendGrid API key in appsettings (encrypted)
Log all sent emails (EmailLog table optional for Phase 2)
Respect unsubscribe preferences (Phase 3+)
Rate limit: Don't send duplicate emails within 24 hours


2.5 Subscription Tier Enforcement
Feature Gates by Tier:
Basic ($79/mo):
- All Phase 1 features
- Photo uploads
- Email notifications
- CSV exports

Standard ($129/mo):
- All Basic features
- Square POS integration
- Auto-sync transactions

Plus ($179/mo):
- All Standard features  
- Square Online integration (Phase 4)

Premium ($229/mo):
- All Plus features
- QuickBooks Online auto-sync (Phase 3)
Enforcement:

Backend: Attribute [RequiresTier(SubscriptionTier.Standard)] on controllers/methods
Frontend: Hide/disable UI elements based on current tier
Upgrade prompts: "Upgrade to Standard to enable Square POS integration"
Grace period: If subscription lapses, show 7-day grace period before blocking access


Phase 2 Database Migrations
New Tables:

SubscriptionEvent
SquareConnection
SquareSyncLog

Updated Tables:

Organization - no changes needed (Stripe fields already exist from Phase 1)
Transaction - add Square fields
Item - no schema changes (Photos field already exists)

Indexes:

SquareConnection.OrganizationId (unique)
SquareSyncLog.OrganizationId
Transaction.SquarePaymentId (unique, sparse)
SubscriptionEvent.StripeEventId (unique)


Phase 2 Frontend Requirements
New Pages:

Pricing Page (/pricing)

Tier comparison table
Founder pricing banner (if available)
"Start Free Trial" CTA
"Subscribe" buttons for each tier


Billing Settings (/settings/billing)

Current plan & price
Next billing date
Payment method (masked)
Upgrade/downgrade UI
"Manage Payment Method" (Stripe portal)
"Cancel Subscription"
Invoice history


Integrations Hub (/settings/integrations)

Square POS card:

Connection status
"Connect" / "Disconnect" button
Last sync timestamp
"Sync Now" button
Auto-sync settings


QuickBooks card (Phase 3 - greyed out with "Upgrade to Premium" badge)


Unmatched Transactions (/square/unmatched)

Table showing transactions that couldn't auto-match
Match UI with suggested matches
Bulk operations



Updated Pages:

Dashboard - Add widgets:

Subscription status banner (trial countdown, payment due, etc.)
Unmatched Square transactions count badge


Item Form - Add:

Photo upload widget (drag/drop, up to 5 photos)
Photo gallery/carousel


Settings - Add navigation:

Billing
Integrations
(Profile already exists from Phase 1)



UI Components:

Tier badge component (shows current tier with color coding)
Upgrade prompt modal (when accessing locked features)
Photo uploader component (reusable)
Subscription status banner component


Phase 2 Background Jobs
Required Scheduled Tasks:

Square Auto-Sync (if enabled)

Frequency: Based on organization's SyncSchedule (default: daily at midnight)
Action: Call SquareService.SyncTransactionsAsync()
Error handling: Log failure, send email to shop owner


Stripe Token Refresh (proactive)

Frequency: Daily
Action: Check all SquareConnections where TokenExpiry < 7 days, refresh tokens


Trial Expiration Warnings

Frequency: Daily at 9am
Action: Find orgs where trial expires in 3 days, send email


Subscription Status Sync (safety net)

Frequency: Hourly
Action: For Active subscriptions, check if payment failed but webhook missed
Fallback in case webhooks fail



Implementation:

Use Hangfire or built-in .NET BackgroundService
Store job history in database (JobLog table - optional for Phase 2)


Phase 2 Security & Infrastructure
Encryption:

Square tokens: Encrypt before storing in database
Use .NET Data Protection API or AES-256
Store encryption key in Azure Key Vault or appsettings (secured)

API Rate Limiting:

Square API: 10 requests/second - implement exponential backoff
Stripe API: No strict limit, but use reasonable delays between bulk operations

CORS Updates:

Allow Stripe Checkout domain
Allow Square OAuth redirect

Environment Variables:
STRIPE_SECRET_KEY
STRIPE_PUBLISHABLE_KEY
STRIPE_WEBHOOK_SECRET
SQUARE_APPLICATION_ID
SQUARE_APPLICATION_SECRET
SQUARE_WEBHOOK_SIGNATURE_KEY
SENDGRID_API_KEY
AZURE_STORAGE_CONNECTION_STRING
AZURE_STORAGE_CONTAINER_NAME

Phase 2 Testing Requirements
Critical Flows to Test:

Stripe Subscription:

Create trial subscription
Add payment method during trial
Trial → Active conversion
Failed payment → PastDue status
Upgrade tier (proration)
Downgrade tier (at period end)
Cancel subscription


Square Integration:

OAuth connect flow
Sync transactions (auto-match)
Sync transactions (manual match)
Token refresh
Disconnect
Webhook delivery


Photo Upload:

Upload single photo
Upload 5 photos
Delete photo
Exceed 10MB limit (should fail)
Invalid file type (should fail)


Tier Enforcement:

Basic tier: Cannot access Square features
Standard tier: Can access Square features
Expired subscription: Show paywall



Test Data:

Create Stripe test products for all tiers
Use Square Sandbox environment
Test with different vertical types


Phase 2 Success Criteria
Phase 2 is complete when:

✅ Shop owner can subscribe to any tier via Stripe Checkout
✅ Founder pricing automatically assigned to first 30 customers
✅ 14-day trial works (no payment required to start)
✅ Stripe webhooks update subscription status correctly
✅ Shop owner can upgrade/downgrade/cancel subscription
✅ Shop owner can connect Square POS via OAuth
✅ Square transactions auto-sync daily
✅ Auto-matched transactions create proper splits
✅ Unmatched transactions show in manual match UI
✅ Shop owner can upload photos to items (up to 5)
✅ Photos stored in Azure Blob Storage
✅ Emails sent for: welcome, trial expiring, payment failed
✅ Tier-gated features enforced (frontend & backend)
✅ Square features blocked for Basic tier users
✅ All Phase 2 migrations successful
✅ No breaking changes to Phase 1 functionality


Phase 3: QuickBooks Online API & Provider Portal
Timeline: Weeks 7-10 (4 weeks)
Phase 3 Overview
Add QuickBooks Online integration for automated accounting and launch the provider portal so providers can view their inventory, sales, and payouts. Available for Premium tier customers only.
Prerequisites: Phase 2 complete

Phase 3 Requirements
3.1 QuickBooks Online Integration
Business Requirements:

OAuth connection to QuickBooks Online
Bi-directional sync: ConsignmentPro → QuickBooks
Auto-create:

Sales Receipts (for each transaction)
Bills (for each payout)
Vendors (for each provider)


Map provider payment methods to QB accounts
Sync status dashboard (view sync history, errors, retry failures)
Manual retry for failed syncs
Only available for Premium tier ($229/mo)

Technical Requirements:
New Database Entities:
QuickBooksConnection
- OrganizationId (FK, unique)
- IsConnected (bool)
- RealmId (string - QB company ID)
- AccessToken (string, encrypted)
- RefreshToken (string, encrypted)
- TokenExpiry (datetime)
- LastSyncAt (datetime?)
- AutoSync (bool, default true)
- SyncDirection (enum: OneWay, TwoWay - Phase 3: OneWay only)

QuickBooksSyncLog
- OrganizationId (FK)
- EntityType (enum: Transaction, Payout, Provider)
- EntityId (Guid - FK to Transaction/Payout/Provider)
- SyncStarted (datetime)
- SyncCompleted (datetime?)
- Success (bool)
- QuickBooksId (string? - returned QB entity ID)
- ErrorMessage (string?)
- RetryCount (int, default 0)
Organization Table (already has QB fields from Phase 1):

QuickBooksConnected
QuickBooksRealmId
QuickBooksAccessToken (encrypted)
QuickBooksRefreshToken (encrypted)
QuickBooksTokenExpiry
QuickBooksLastSync

Transaction Table (already has QB fields from Phase 1):

SyncedToQuickBooks
SyncedAt
QuickBooksSalesReceiptId
QuickBooksSyncFailed
QuickBooksSyncError

Payout Table (already has QB fields from Phase 1):

SyncedToQuickBooks
SyncedAt
QuickBooksBillId
QuickBooksSyncFailed
QuickBooksSyncError

Provider Table - Add:

QuickBooksVendorId (string?)
QuickBooksVendorName (string? - for display/validation)

Backend Service: IQuickBooksService
Methods needed:

GetAuthorizationUrlAsync(organizationId) → OAuth URL
ExchangeCodeForTokenAsync(code, realmId, state) → OAuthResult
DisconnectAsync(organizationId) → bool
RefreshAccessTokenAsync(organizationId) → bool
SyncProviderAsync(providerId) → Creates/updates Vendor in QB
SyncTransactionAsync(transactionId) → Creates Sales Receipt in QB
SyncPayoutAsync(payoutId) → Creates Bill in QB
BulkSyncAsync(organizationId, entityType, startDate, endDate) → SyncBatchResult
RetrySyncAsync(syncLogId) → bool
GetSyncStatusAsync(organizationId) → SyncStatusSummary

QuickBooks Mapping Logic:

Provider → Vendor:

Display Name → Vendor Name
Email → Vendor Email
Phone → Vendor Phone
PaymentMethod → Preferred Payment Method
Check for duplicate by email before creating


Transaction → Sales Receipt:

SaleDate → TxnDate
SalePrice → Line.Amount (Item line)
ProviderAmount → Line.Amount (mapped to Vendor expense account)
ShopAmount → Deposit To (shop income account)
PaymentMethod → PaymentMethodRef
Memo: "Sale of {Item.Title} via ConsignmentPro"


Payout → Bill:

PeriodEnd → DueDate
Provider → VendorRef
TotalAmount → TotalAmt
Line items: Individual transactions included in payout
Memo: "Payout for period {PeriodStart} to {PeriodEnd}"



Sync Process:

On Transaction Create (if AutoSync enabled):

Create Sales Receipt in QB immediately
If fails: Mark QuickBooksSyncFailed, log error, retry in background job


On Payout Marked as "Paid" (if AutoSync enabled):

Create Bill in QB
If fails: Mark QuickBooksSyncFailed, log error, retry in background job


Background Sync Job (daily):

Find all entities where SyncedToQuickBooks = false
Attempt sync for each
Retry previously failed syncs (up to 3 attempts)
Send email summary if any failures persist



API Endpoints:
GET    /api/quickbooks/connect-url         - Get OAuth URL
GET    /api/quickbooks/oauth-callback      - OAuth callback
POST   /api/quickbooks/disconnect          - Disconnect QB
GET    /api/quickbooks/status              - Connection status
POST   /api/quickbooks/sync-now            - Trigger manual sync {entityType, entityId?}
POST   /api/quickbooks/retry               - Retry failed sync {syncLogId}
GET    /api/quickbooks/sync-logs           - Get sync history
GET    /api/quickbooks/sync-summary        - Dashboard stats {synced, pending, failed}
POST   /api/quickbooks/validate-mapping    - Test mapping before enabling AutoSync
Frontend Requirements:

Settings > Integrations > QuickBooks Online:

"Connect QuickBooks" button (only if Premium tier)
Connection status (Connected to: {Company Name}, Last sync: X)
"Disconnect" button
Auto-sync toggle
Account mapping UI:

Income Account (shop revenue)
Expense Account (provider payouts)
Default Payment Method


"Validate Mapping" button (creates test transaction in QB)
"Sync Now" button (manual bulk sync)


Dashboard widget:

QuickBooks sync status
Pending syncs count
Failed syncs count (red badge)


New page: QuickBooks Sync History (/quickbooks/history)

Table: Entity Type, Entity Name, Date, Status, QB ID, Error
"Retry" button for failed syncs
Filter by: Entity Type, Status, Date Range


Transaction/Payout detail pages:

Show sync status badge (Synced ✓, Pending, Failed ⚠️)
"View in QuickBooks" link (if synced)
"Retry Sync" button (if failed)



Constraints:

Only Premium tier can connect QuickBooks
Token refresh: QuickBooks tokens expire after 100 days - refresh proactively
Rate limit: 500 requests/minute - implement throttling
Sandbox vs Production: Use QB Sandbox for testing
Error handling: Duplicate detection, validation errors, network failures
Company switching: If user disconnects and reconnects to different QB company, warn that it will create duplicates


3.2 Provider Portal
Business Requirements:

Shop owners can invite providers to create accounts
Providers receive magic link email (no password)
Provider dashboard shows:

Their items (title, price, status, photo)
Their sales history
Their payout history
Current balance (unpaid amount)


Providers can view details but cannot edit (read-only)
Email notifications:

Item sold
Payout ready
Payout completed


Invitation expiration (7 days)
Providers can access from any device (responsive)

Technical Requirements:
New Database Entities:
ProviderInvitation
- Id (Guid, PK)
- ProviderId (FK)
- OrganizationId (FK)
- Email (string)
- InvitationToken (string, unique) - Magic link token
- ExpiresAt (datetime)
- AcceptedAt (datetime?)
- CreatedBy (Guid - UserId of shop owner)
- CreatedAt (datetime)

ProviderNotificationSetting
- ProviderId (FK, unique)
- EmailOnItemSold (bool, default true)
- EmailOnPayoutReady (bool, default true)
- EmailOnPayoutPaid (bool, default true)
Provider Table - Add:

UserId (already exists, nullable from Phase 1)

User Table:

Role enum already includes "Provider" from Phase 1
Email
PasswordHash (NULL for providers - they use magic links)
OrganizationId

Backend Service: IProviderInvitationService
Methods:

CreateInvitationAsync(providerId, shopOwnerUserId) → InvitationToken
AcceptInvitationAsync(token) → LoginResult
ResendInvitationAsync(providerId) → bool
CancelInvitationAsync(invitationId) → bool
GetPendingInvitationsAsync(organizationId) → List<ProviderInvitation>

Backend Service: IProviderPortalService
Methods:

GetProviderDashboardAsync(providerId) → ProviderDashboard
GetProviderItemsAsync(providerId, filters) → List<Item>
GetProviderTransactionsAsync(providerId, filters) → List<Transaction>
GetProviderPayoutsAsync(providerId, filters) → List<Payout>
GetCurrentBalanceAsync(providerId) → decimal
UpdateNotificationSettingsAsync(providerId, settings) → bool

Provider Dashboard Data:
csharppublic class ProviderDashboard
{
    public string DisplayName { get; set; }
    public int TotalItems { get; set; }
    public int AvailableItems { get; set; }
    public int SoldItems { get; set; }
    public decimal TotalSales { get; set; }
    public decimal TotalPayouts { get; set; }
    public decimal CurrentBalance { get; set; }  // Unpaid amount
    public DateTime? LastPayoutDate { get; set; }
    public DateTime? NextPayoutDate { get; set; }  // Estimated
    public List<RecentSale> RecentSales { get; set; }
    public List<RecentPayout> RecentPayouts { get; set; }
}
Magic Link Authentication:

Token format: 32-character random string
URL: https://app.com/provider/accept-invitation?token={token}
On click:

Validate token (not expired, not used)
Create User record (Role: Provider, Email from Provider, PasswordHash: NULL)
Link Provider.UserId → User.Id
Mark invitation as accepted
Generate JWT token
Redirect to provider dashboard


Subsequent logins:

Provider clicks "Login as Provider"
Enters email
System sends new magic link (15-minute expiry)
Email contains link: https://app.com/provider/magic-login?token={token}
On click: Generate JWT, redirect to dashboard



API Endpoints:
Shop Owner (managing providers):
POST   /api/providers/{providerId}/invite     - Send invitation
POST   /api/providers/{providerId}/resend     - Resend invitation
GET    /api/providers/invitations             - Get pending invitations
DELETE /api/providers/invitations/{id}        - Cancel invitation
Provider Portal (Provider-only access):
GET    /api/provider/accept-invitation        - Accept invitation {token}
POST   /api/provider/magic-login              - Request magic link {email}
GET    /api/provider/verify-magic             - Verify magic link {token}
GET    /api/provider/dashboard                - Get dashboard data
GET    /api/provider/items                    - Get my items {status?, page, pageSize}
GET    /api/provider/transactions             - Get my sales {startDate?, endDate?, page}
GET    /api/provider/payouts                  - Get my payouts {status?, startDate?, endDate?}
GET    /api/provider/balance                  - Get current unpaid balance
PUT    /api/provider/notifications            - Update notification settings
GET    /api/provider/profile                  - Get provider profile (read-only)
Email Templates (SendGrid):

Provider Invitation:

Subject: "{Organization Name} has invited you to view your consignment account"
Body: Welcome message, explanation, "Accept Invitation" CTA button
Link expires in 7 days


Magic Login:

Subject: "Your login link for {Organization Name}"
Body: "Click here to log in (expires in 15 minutes)"


Item Sold:

Subject: "Your item has sold!"
Body: Item details, sale price, your amount, shop amount
CTA: "View Sale Details"


Payout Ready:

Subject: "Your payout is ready"
Body: Total amount, period, items included count
CTA: "View Payout Details"


Payout Completed:

Subject: "Your payout has been processed"
Body: Amount, payment method, transaction details
CTA: "View Payout History"



Frontend Requirements:
Provider Portal Pages (separate from shop owner UI):

Provider Login (/provider/login)

Email input
"Send Magic Link" button
"Check your email" success message


Provider Dashboard (/provider/dashboard)

KPI cards: Total Items, Sold Items, Total Sales, Current Balance
Recent Sales table (last 10)
Recent Payouts table (last 5)
Welcome banner with provider name


My Items (/provider/items)

Filterable table: All / Available / Sold / Returned
Columns: Photo, Title, SKU, Price, Status, Date Added
Read-only (no edit/delete)


My Sales (/provider/transactions)

Table: Date, Item, Sale Price, Your Amount, Shop Amount, Payout Status
Filters: Date range, Paid/Unpaid
Export to CSV


My Payouts (/provider/payouts)

Table: Period, Amount, Paid Date, Payment Method, Items Count
Click to expand: See included transactions
Download PDF receipt


Settings (/provider/settings)

Profile (read-only): Name, Email, Phone, Split %
Notification preferences (toggles)
Payment method info (read-only, set by shop owner)



Provider UI Design:

Separate branding from shop owner UI
Mobile-first responsive design
Limited navigation (Dashboard, Items, Sales, Payouts, Settings)
No provider can see other providers' data (enforce organizationId + providerId)

Constraints:

Providers cannot edit anything
Providers see only their own data
Magic links expire: Invitation (7 days), Login (15 minutes)
Providers cannot delete their account (contact shop owner)
Email notifications respect provider's preferences
One provider account per email per organization


3.3 Enhanced Email Notifications
Additional Email Types (Phase 3):

Provider invitation
Provider magic login
Item sold (to provider)
Payout ready (to provider)
Payout completed (to provider)
QuickBooks sync failed (to shop owner)
Provider joined (to shop owner)

Email Service Updates:
Extend IEmailService with:

SendProviderInvitationAsync(email, organizationName, invitationLink, expiresAt)
SendMagicLoginAsync(email, magicLink, expiresAt)
SendItemSoldNotificationAsync(providerEmail, itemTitle, salePrice, providerAmount)
SendPayoutReadyAsync(providerEmail, amount, periodStart, periodEnd, itemsCount)
SendPayoutCompletedAsync(providerEmail, amount, paymentMethod, paidDate)
SendQuickBooksSyncFailedAsync(shopOwnerEmail, failedCount, errorSummary)

Email Preferences:

Providers can toggle notifications in their settings
Shop owners always receive critical emails (QB sync failures, subscription issues)


Phase 3 Background Jobs
New Scheduled Tasks:

QuickBooks Auto-Sync (if enabled)

Frequency: Hourly
Action: Sync pending transactions/payouts
Retry: Failed syncs (up to 3 attempts)


QuickBooks Token Refresh (proactive)

Frequency: Daily
Action: Refresh tokens expiring in < 30 days


Provider Magic Link Cleanup

Frequency: Daily
Action: Delete expired magic link tokens (> 15 minutes old for login, > 7 days for invitations)


Provider Email Notifications

Trigger: On transaction create (if item sold)
Trigger: On payout status → "Pending" (payout ready)
Trigger: On payout status → "Paid" (payout completed)
Check provider notification settings before sending




Phase 3 Security Requirements
Provider Portal Authorization:

JWT claims MUST include Role = "Provider"
Attribute: [Authorize(Roles = "Provider")] on provider endpoints
Middleware: Validate providerId in claims matches requested data
No cross-provider data access

Magic Link Security:

Tokens are cryptographically random (32 bytes)
Store hashed in database (use BCrypt or SHA-256)
Single-use tokens (mark as used after acceptance)
Expiration enforced strictly
Rate limit magic link requests (max 3 per hour per email)

QuickBooks Token Security:

Encrypt access/refresh tokens before storing
Never log tokens
Rotate encryption keys periodically
Use HTTPS only for OAuth callbacks


Phase 3 Database Migrations
New Tables:

QuickBooksConnection
QuickBooksSyncLog
ProviderInvitation
ProviderNotificationSetting

Updated Tables:

Provider - add QuickBooksVendorId, QuickBooksVendorName
Transaction - no changes (QB fields already exist)
Payout - no changes (QB fields already exist)
User - PasswordHash now nullable (providers don't have passwords)

Indexes:

ProviderInvitation.InvitationToken (unique)
ProviderInvitation.ProviderId
QuickBooksConnection.OrganizationId (unique)
QuickBooksSyncLog.OrganizationId
QuickBooksSyncLog.EntityType + EntityId


Phase 3 Testing Requirements
Critical Flows to Test:

QuickBooks Integration:

OAuth connect
Create Sales Receipt
Create Bill
Create Vendor
Token refresh
Handle QB validation errors
Disconnect and reconnect


Provider Portal:

Send invitation
Accept invitation (create account)
Magic link login
View dashboard
View items/sales/payouts
Update notification preferences
Expired invitation handling
Expired magic link handling


Email Notifications:

All provider emails deliver
Notification preferences respected
Links in emails work
Unsubscribe links work (future)


Authorization:

Provider cannot access shop owner endpoints
Provider cannot see other providers' data
Shop owner cannot access provider portal endpoints



Test Data:

Create QB Sandbox account
Create test providers with various sales/payout scenarios
Test with multiple providers in same organization


Phase 3 Success Criteria
Phase 3 is complete when:

✅ Premium tier customers can connect QuickBooks Online
✅ Transactions auto-sync as Sales Receipts in QB
✅ Payouts auto-sync as Bills in QB
✅ Providers auto-sync as Vendors in QB
✅ QB sync failures logged and retryable
✅ QB token refresh works automatically
✅ Shop owner can invite providers
✅ Providers receive magic link invitation email
✅ Providers can accept invitation and create account
✅ Providers can log in via magic link
✅ Provider dashboard shows correct KPIs
✅ Providers can view their items/sales/payouts
✅ Providers receive emails when items sell
✅ Providers receive emails when payouts are ready/completed
✅ Provider notification preferences work
✅ All provider data properly secured (no cross-provider access)
✅ QB integration only accessible to Premium tier
✅ All Phase 3 migrations successful
✅ No breaking changes to Phase 1 or Phase 2 functionality


Deferred to Future Phases
Phase 4 (Weeks 11-12):

Square Online integration
Bi-directional inventory sync
Online vs in-store reporting

Phase 5+:

Shopify integration
Shopper role & public storefront
Provider self-service (upload own items)
Advanced analytics & reporting
Multi-user staff accounts
QuickBooks Desktop Web Connector (only if strong demand)


Notes for Claude Code
Package Dependencies:

Stripe.net (latest stable)
Square SDK (latest stable)
Intuit QuickBooks SDK (Intuit.Ipp.*)
Azure.Storage.Blobs
Sendgrid
Hangfire (or use BackgroundService)

Configuration:

All API keys in appsettings.json
Use .NET User Secrets for local development
Use Azure Key Vault for production
Connection strings for Neon PostgreSQL

Security:

All external tokens encrypted at rest
HTTPS only in production
CORS properly configured for OAuth callbacks
Rate limiting on sensitive endpoints

Code Standards:

Follow Phase 1 n-tier architecture
Use AutoMapper for DTOs
FluentValidation for input validation
Async/await throughout
Proper error handling with ApiResponse<T> wrapper
Comprehensive logging

Database:

All GUIDs for PKs
All timestamps UTC
Soft deletes where appropriate
Proper indexes on foreign keys
Migration scripts clearly commented

Frontend:

Angular standalone components
Reactive forms
Consistent error handling
Loading states
Toast notifications
Responsive design (mobile-first)
Accessibility (WCAG 2.1 AA)


This completes the Phase 2 and Phase 3 requirements specification. Claude Code should have everything needed to implement these phases following the established patterns from Phase 1.